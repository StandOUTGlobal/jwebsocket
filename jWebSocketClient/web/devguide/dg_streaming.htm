<html>

<head>
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>jWebSocket Streaming</title>
<link rel="stylesheet" type="text/css" href="../res/css/jwebsocket.css">
</head>

<body>

<h2>Streaming</h2>
<p>The streaming model in the jWebSocket Server is designed to broadcast 
internal and/or forward external third party streams to WebSocket clients. 
As almost all functionalities in jWebSocket the streams are implemented as a 
plug-in as well. All streaming related classes are located in the 
<tt>org.jwebsocket.plugins.streaming</tt> package.</p>
<h3>BaseStream</h3>
<p>The fundamental streaming capabilities are provided by the 
<tt>BaseStream</tt> class. The <tt>BaseStream</tt> implements an internal queue to which 
messages can be posted. The message then are broadcasted from the queue to all registered clients. 
To maintain the clients the 
<tt>BaseStream</tt> class uses an internal list. A certain client can register 
at or 
unregister from the stream (see below). Basically streams send their messages only to 
such clients which 
are registered at a stream.</p>
<h3>TokenStream</h3>
<p>Unlike the <tt>BaseStream</tt> which has no control or limitation regarding the 
objects in the Queue, the <tt>TokenStream</tt> only allows tokens in the queue. 
To support the various sub protocols the <tt>TokenStream</tt> does not send the queued 
tokens directly to the clients but via the <tt>TokenServer</tt>. The <tt>TokenServer</tt> 
knows about the used sub protocols of the clients and can decide wether to 
format them as JSON, CSV or XML. Thus application streams usually are descend from <tt>TokenStream</tt> 
to be automatically cross-protocol-compatible.</p>
<h3>TimeStream</h3>
<p>The <tt>TimeStream</tt> is primarily for demonstration purposes but it can 
also be 
used for client/server time synchronization. It implements an internal thread 
which broadcasts the current system time of the server to the registered clients 
once per second. In the demo projects the id of the stream is <tt>timeStream</tt>. 
The id's are used on the clients to refer to a particular stream when 
registering at or unregistering from a stream.</p>
<h3>MonitorStream</h3>
<p>Like the <tt>TimeStream</tt> the monitor stream was designed to demonstrate the 
possibilities of monitoring the jWebSocket Server and its environment. You can 
use it as an example or easily copy and extend it for your own purposes. 
Introduced in jWebSocket v0.8.5 the <tt>MonitorStream</tt> simply sends the total and free 
amount of memory as 
well as the total and free amount of diskspace every second to the registered clients. 
You can run the monitor stream online
<a target="_parent" href="../demos/streaming/streaming.htm">here</a>. A web client 
e.g. could use this data to draw SVG charts or diagrams or raise warnings. The 
stream class also could send E-mails in the case certain limits are exceeded.</p>
<h3>StreamingPlugin</h3>
<p>The <tt>StreamingPlugin</tt> maintains the various streams in jWebSocket. To 
use a custom specific stream in jWebSocket you simply add it after its instantiation to 
the map of streams in the <tt>StreamingPlugin</tt> by using the <tt>addStream</tt> method 
(see listing below). You can create your own stream classes based on <tt>TokenStream</tt> 
and add it in the same way as shown in the listing. Don't forget to assign a 
unique id to the stream which is used by the client for registering and 
unregistering.</p>



<blockquote><pre class="listing"><span style="font-family:" monospaced",monospace; color:#000000; white-space: pre;"><span style="color:#969696;">// create the token server</span>
TokenServer tokenServer = <span style="color:#0000e6;">null</span>;
StreamingPlugIn streamingPlugIn = <span style="color:#0000e6;">null</span>;

<span style="color:#0000e6;">try</span> {
  <span style="color:#969696;">// instantiate the Token server...</span>
  tokenServer = <span style="color:#0000e6;">new</span> TokenServer(<span style="color:#ce7b00;">&quot;ts0&quot;</span>);
  <span style="color:#969696;">// the token server already instantiates a plug-in chain</span>
  TokenPlugInChain plugInChain = tokenServer.getPlugInChain();
</span><span style="font-family:" monospaced",monospace; color:#000000; white-space: pre;">  :
</span><span style="font-family:" monospaced",monospace; color:#000000; white-space: pre;">  <span style="color:#969696;">// create and add the streaming plug-in (e.g. for the time stream and monitor demo)</span>
  plugInChain.addPlugIn(streamingPlugIn = <span style="color:#0000e6;">new</span> StreamingPlugIn());
  :
} <span style="color:#0000e6;">catch</span> (Exception ex) {
</span><span style="font-family:" monospaced",monospace; color:#000000; white-space: pre;">  :
</span><span style="font-family:" monospaced",monospace; color:#000000; white-space: pre;">}

<span style="color:#969696;">// initialize streaming sub system...</span>
<span style="color:#0000e6;">if</span> (streamingPlugIn != <span style="color:#0000e6;">null</span>) {
  <span style="color:#969696;">// create the stream for the time stream demo</span>
  TimeStream lTimeStream = <span style="color:#0000e6;">new</span> TimeStream(<span style="color:#ce7b00;">&quot;timeStream&quot;</span>, tokenServer);
  streamingPlugIn.addStream(lTimeStream);
  <span style="color:#969696;">// create the stream for the monitor stream demo</span>
  MonitorStream lMonitorStream = <span style="color:#0000e6;">new</span> MonitorStream(<span style="color:#ce7b00;">&quot;monitorStream&quot;</span>, tokenServer);
  streamingPlugIn.addStream(lMonitorStream);
}</span><p class="imageFooter">Creating multiple streams and binding them to the streaming plugin</p></pre></blockquote>



</body>

</html>