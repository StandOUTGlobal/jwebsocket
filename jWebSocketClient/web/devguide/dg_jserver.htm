<html>

<head>
<meta http-equiv="Content-Language" content="de">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>jWebSocket Java Server</title>
<link rel="stylesheet" type="text/css" href="../res/css/jwebsocket.css">
</head>

<body>

<h2>Connectors, Engines and Servers</h2>
<p>The WebSocket protocol is based on simple TCP socket communication with an initial 
handshake. After the handshake has successfully been processed the connection 
provides a full duplex (bi-directional) communication channel between the server 
and the client w/o any HTTP overhead or content restrictions. Depending on its 
dimension a single server can handle hundreds of concurrent client connections. 
Due to the extensible structure of the jWebSocket approach multiple servers can 
be clustered to support an almost unlimited number of clients (targetted for 
jWebSocket release 2.0).</p>
<p>In jWebSocket each client is connected to a connector on the jWebSocket 
Server. Connectors are driven by an engine like e.g. the jWebSocket internal 
TCPEngine or third party engines like JBoss Netty. The server core in jWebSocket 
can drive multiple engines to benefit from their individual features like the 
SSL support. The following diagram first gives you an overview over the 
jWebSocket communication infrastructure.</p>
<p>
<img class="diagram" border="0" src="../images/infra_server.jpg" ></p>
<p class="imageFooter">Connectors, Engines and Servers in the jWebSocket 
communication stack</p>
<br/>
<p>Details pending...</p>

<!--
		<h2><a name="Connectors"></a>Connectors</h2>
<p>The jWebSocket connectors are the interface to 
internet. Each client connection is processed by its own connector instance on 
the jWebSocket Server. Each connector exchanges messages with its connected client on the same 
single TCP socket 
connection. Therefore each connector provides a receive thread as 
well as a send queue, including a full session timeout management.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>Each server can instantiate up to hundreds of connectors, depending on its 
dimension, the network bandwidth and the application requirements. Each 
connector maintains its Java Socket(client) instance, a backward reference to 
its server as well as the information from which host, path and origin the 
connection was established and the outgoing socket port.</p>
<h3>BaseConnector</h3>
<p>Implements the basic HTML 5 WebSocket communication capabilities and the 
WebSocket protocol handshake. It further implements all required methods to 
handle incoming requests from the client who is bound to this connector and in 
the other direction send data back to client.</p>
<p>The <code>BaseConnector</code> does neither produce any log output nor any user, group or session management is implemented. 
Hence we encourage you to use the high level classes for your convenience. 
However, this can be used only if you want to create your own low level 
(i.e. non-token based) protocol.</p>
<h3>TokenConnector</h3>
<p>The <code>TokenConnector</code> is a direct descendant from the <code>BaseConnector</code> class and beside 
all logging and exception handling it implements the token based communication 
and the timeout, user, group, authentication and sessionhandling. This class uses the 
log4j logs, thus the log needs to be initialized.</p>
<p>To parse the data stream from the clients to create a token on the server it declares the 
abstract <code>streamToToken</code> 
method. In the other direction to create a data stream from a Java token it 
declares the <code>tokenToStream</code> method. Both methods need to be 
overwritten by descendant classes. It is not supposed to create direct instances of 
the <code>TokenConnector</code> 
class.</p>
<h3>UserConnector</h3>
<p>This class demonstrates how you easily can implement your own WebSocket 
communication protocol based on the fundamental <code>BaseConnector</code>. This is useful 
particularly when you intend to implement your own protocol w/o coming back to 
the token based protocol of the <code>org.jWebSocket.connectors.TokenConnector class</code>. Anyway, we recommend 
to implement your solutions on top of the <code>TokenConnector</code> and its 
descendants because here you will benefit from all future extensions of the 
jWebSocket server and do not need to be aware of all the low level communication.</p>
<h3>Engines</h3>
<p>&nbsp;</p>
<p>jWebSocket provides his own native TC</p>
<p>&nbsp;</p>
<p>Each jWebSocket server maintains a set of <a href="#Connectors">connectors</a> 
(clients) as well as a chain of <a href="dg_plugins.htm">plug-ins</a>. The 
connectors provide the interface to the internet, the plug-ins are system or custom 
server extensions which process incoming events from the clients. The so called 
&quot;system plug-in&quot; processes the predefined jWebSocket messages. Messages which are 
not processed by the system plug-in are passed through a chain of further system 
or custom plug-ins in 
a customizable order (for an overview please refer to the corresponding
<a href="../infra_listenerchain.htm">plug-in diagram</a>). The plug-ins are the 
API for any kind of custom jWebSocket based communication or streaming 
applications.</p>
<h3>BaseServer</h3>
<p>The <code>org.jWebSocket.server.BaseServer</code> class is the parent class for all jWebSocket servers. 
It holds the Java server socket and maintains the set of connectors as 
well as the plug-in chain for that certain server instance. Furthermore it holds the default 
session timeout for its connectors if not explicitly passed. There is neither a 
logging support implemented in this tier nor an exception handling, these are 
passed through. Both are supposed to be done in the descendant classes.</p>
<h4>Maintaining Connectors</h4>
<p>To handle new client connection and their termination the base server provide 
the two methods <code>connectorStarted</code> and <code>connectorTerminated</code>. 
Descendant classes can handle these events by overwriting these two methods. To 
create a connector the <code>BaseServer</code> class implements the <code>createConnector</code> 
method. Descendant classes overwrite this method to instantiate their own 
protocol specific connectors e.g. for JSON, CSV or XML based communication.</p>
<h4>Broadcasting Messages</h4>
<p>To broadcast a message to all clients via the connectors the <code>BaseServer</code> class 
provides the <code>broadcast</code> method. A message is a Java 
<code>Object</code> class instance. Currently its <code>toString()</code> method is used to&nbsp;generate 
the data stream to be broadcasted. There is no way to limit the broadcast to 
a certain set of clients because on this communication tier no client IDs or 
session IDs are maintained to address certain clients or groups. To do this please refer to the higher level classes 
described below. 
For special purposes you can create your own direct descendants of the 
<code>BaseServer</code> class, but we encourage you to benefit from the higher level 
<code>TokenServer</code> class and its descandants.</p>
<h4>Processing Server Start/Stop Events</h4>
<p>To handle new server instantiation and their termination e.g. to allocate and 
release required resources the <code>BaseServer</code> provides 
the two methods <code>serverStarted</code> and <code>serverTerminated</code>. 
Descendant classes can handle these events by overwriting these two methods.</p>
<p>For more information to the <code>BaseServer</code> class please refer to the JavaDoc.</p>
<h3>TokenServer</h3>
<p>The <code>org.jWebSocket.server.TokenServer</code> class is the base class for the <code>JSONServer</code>, 
the <code>CSVServer</code> and the <code>XMLServer</code> classes as well as for all custom specific token 
based WebSocket server classes. In the current version of jWebSocket the only purpose of this class is to 
catch potential exceptions of the <code>BaseServer</code> from which it derives and implement 
the basic logging as an additional feature. There is no reason to create direct instances 
from the <code>TokenServer</code> class. Please refer to its descendant classes <code>JSONServer</code>,
<code>CSVServer</code> and <code>XMLServer</code>.</p>
<h3>JSONServer</h3>
<p>The <code>org.jWebSocket.server.JSONServer</code> class implements the 
jWebSocket JSON server.&nbsp;As a direct descendant of the <code>TokenServer</code> it also 
inherits all the capabilities of the <code>BaseServer</code>. Its primary purpose is to 
instantiate connectors of the <code>JSONConnector</code> class by overwriting the 
<code>createConnector</code> method of its ancestor. You can create one or more 
direct instances of the <code>JSONServer</code> in a single application but please consider 
that every server instance has to listen on its own socket port.</p>
<h3>CSVServer</h3>
<p><i>Targeted for jWebSocket release 1.1</i></p>
<p>The <code>org.jWebSocket.server.CSVServer</code> class implements the 
jWebSocket CSV server.&nbsp;As a direct descendant of the <code>TokenServer</code> it also 
inherits all the capabilities of the <code>BaseServer</code>. Its primary purpose is to 
instantiate connectors of the <code>CSVConnector</code> class by overwriting the 
<code>createConnector</code> method of its ancestor. You can create one or more 
direct instances of the <code>CSVServer</code> in a single application but please consider 
that every server instance has to listen on its own socket port.</p>
<h3>XMLServer</h3>
<p><i>Targeted for jWebSocket release 1.1</i></p>
<p>The <code>org.jWebSocket.server.XMLServer</code> class implements the 
jWebSocket XML server.&nbsp;As a direct descendant of the <code>TokenServer</code> it also 
inherits all the capabilities of the <code>BaseServer</code>. Its primary purpose is to 
instantiate connectors of the <code>XMLConnector</code> class by overwriting the 
<code>createConnector</code> method of its ancestor. You can create one or more 
direct instances of the <code>XMLServer</code> in a single application but please consider 
that every server instance has to listen on its own socket port.</p>
		<h2>JWebSocket Main Class</h2>
<p>Contains the main class including the log initialization for the stand-alone 
version of the jWebSocket Server.</p>
-->
</body>

</html>