//	---------------------------------------------------------------------------
//	jWebSocket - Basic Connector
//	Copyright (c) 2010 Alexander Schulze, Innotrade GmbH
//	---------------------------------------------------------------------------
//	This program is free software; you can redistribute it and/or modify it
//	under the terms of the GNU General Public License as published by the
//	Free Software Foundation; either version 3 of the License, or (at your
//	option) any later version.
//	This program is distributed in the hope that it will be useful, but WITHOUT
//	ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
//	FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
//	more details.
//	You should have received a copy of the GNU General Public License along
//	with this program; if not, see <http://www.gnu.org/licenses/>.
//	---------------------------------------------------------------------------
package org.jWebSocket.connectors;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.net.Socket;
import java.net.SocketTimeoutException;
import org.jWebSocket.server.BaseServer;
import org.jWebSocket.server.Header;

/**
 *
 * @author aschulze
 */
public class BaseConnector extends Thread {

	private BaseServer server = null;
	private BufferedReader br = null;
	private PrintStream os = null;
	private Socket clientSocket = null;
	private boolean isRunning = false;
	private Header header = null;

	/**
	 *
	 * @param aServerSocket Backward reference to the socket server instance for this connector.
	 * @param aClientSocket Reference to the socket client instance for this connector.
	 * @param aHeader Header record generated by the Handshake processor.
	 */
	public BaseConnector(BaseServer aServerSocket, Socket aClientSocket, Header aHeader) {
		server = aServerSocket;
		clientSocket = aClientSocket;
		header = aHeader;
	}

	/**
	 * Sends the data of an object directly to the socket output stream.
	 * @param aObject
	 * @throws UnsupportedEncodingException
	 * @throws IOException
	 */
	public void send(Object aObject)
		throws UnsupportedEncodingException, IOException {
		byte[] ba = aObject.toString().getBytes("UTF-8");
		os.write(0);
		os.write(ba);
		os.write(255);
		os.flush();
	}

	/**
	 * Called, when the thread for the connector has been started.
	 * May be overwriten on demand.
	 */
	public void clientThreadStarted() {
	}

	/**
	 * Called, when after handshake was successfully processed.
	 * May be overwriten on demand.
	 */
	public void handshakeSent() {
	}

	/**
	 * Called, when the session timeout for this connector exceeded.
	 * May be overwriten on demand.
	 */
	public void timeoutExceeded() {
	}

	/**
	 * Called, when the session was intentionally closed.
	 * May be overwriten on demand.
	 */
	public void clientClosed() {
		// method may be overwriten on demand
	}

	/**
	 * Called, when the connector received a data packet from the client.
	 * May be overwriten on demand.
	 * @param aObject
	 */
	public void dataReceived(Object aObject) {
		getWebSocketServer().getPlugInChain().processData(this, aObject);
	}

	/**
	 * Called, when the client thread stopped, usually after a disconnect.
	 * May be overwriten on demand.
	 */
	public void clientThreadStopped() {
	}

	@Override
	public void run() {
		String line;
		try {
			br = new BufferedReader(new InputStreamReader(clientSocket.getInputStream(), "UTF-8"));
			os = new PrintStream(clientSocket.getOutputStream(), true, "UTF-8");

			// allow descending classes to handle handshakeSent event
			handshakeSent();

			// start client listener loop
			isRunning = true;
			while (isRunning) {
				// try to read line within timeout
				try {
					line = br.readLine();
					if (line == null) {
//						System.out.println("line is null");
						clientClosed();
					} else {
						// cut off potential starting 0x00 and 0xff characters
						byte[] ba = line.getBytes();
						/*
						// System.out.println("Got chars: " + line.charAt(0) + ", " + line.charAt(1) + ", " + line.charAt(2));
						if( ba.length >= 3 ) {
						System.out.println("Got 3+ bytes: " + ba[0] + ", " + ba[1] + ", " + ba[2] );
						} else if( ba.length >= 2 ) {
						System.out.println("Got 2+ bytes: " + ba[0] + ", " + ba[1] );
						} else if( ba.length >= 1 ) {
						System.out.println("Got 1+ bytes: " + ba[0]);
						}
						 */
						// if no content or only one byte different from 0...
						if (ba.length <= 0 | (ba.length == 1 && ba[0] != 0)) {
							line = null;
							// if byte 0 at pos. 0 is found may be an empty string was sent
						} else if (ba.length >= 1 && ba[0] == 0 && line.length() >= 1) {
							line = line.substring(1);
							// if byte 0 at pos. 1 the rest must be the user data
						} else if (ba.length >= 2 && ba[1] == 0 && line.length() >= 2) {
							line = line.substring(2);
						}
					}
				} catch (SocketTimeoutException ex) {
					timeoutExceeded();
					line = null;
				}
				if (line != null) {
					dataReceived(line);
				} else {
					isRunning = false;
				}
			}

			clientThreadStopped();

			// call client stopped method of server 
			// (e.g. to releas client from streams)
			getWebSocketServer().connectorTerminated(this);

			br.close();
			getOutputStream().close();
			getClientSocket().close();
		} catch (Exception ex) {
			// ignore this exception for now
			System.out.println("BaseConnector: " + ex.getClass().getName() + ": " + ex.getMessage());
		}
	}

	/**
	 * explicitly closes this connection.
	 * @throws IOException
	 * @throws InterruptedException
	 */
	public void terminate() throws IOException, InterruptedException {
		isRunning = false;
		br.close();
		sleep(250);
	}

	/**
	 * Every connector has a backward reference to the underlying jWebSocket
	 * server instance.
	 * @return the BaseServer
	 */
	public BaseServer getWebSocketServer() {
		return server;
	}

	/**
	 * 
	 * @return the origin
	 */
	public String getOrigin() {
		return getHeader().getString("origin");
	}

	/**
	 * 
	 * @return the location
	 */
	public String getLocation() {
		return getHeader().getString("location");
	}

	/**
	 * Here the output stream of the underlying client socket can directly be
	 * accessed. Usually it should not be needed to use this low level method.
	 * For high-level send operations please refer to the sendToken method of
	 * the TokenConnector class.
	 * @return the output stream of the client socket
	 */
	public PrintStream getOutputStream() {
		return os;
	}

	/**
	 * Here the underlying client socket for this connector directly can be 
	 * accessed. Usually an application does not need this low-level access.
	 * For high-level send operations please refer to the methods of the
	 * TokenConnector class.
	 * @return the clientSocket
	 */
	public Socket getClientSocket() {
		return clientSocket;
	}

	/**
	 *
	 * @return the path (part of the header)
	 */
	public String getPath() {
		return getHeader().getString("path");
	}

	/**
	 *
	 * @return the searchString (part of the header)
	 */
	public String getSearchString() {
		return getHeader().getString("searchString");
	}

	/**
	 *
	 * @return the host (part of the header)
	 */
	public String getHost() {
		return getHeader().getString("host");
	}

	/**
	 * @return the header
	 */
	public Header getHeader() {
		return header;
	}
}
